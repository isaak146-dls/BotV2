import requests
from bs4 import BeautifulSoup
import json
import os
import time
import random
from datetime import datetime

# --- CONFIGURACIÃ“N ---
LISTA_USUARIOS = ["m0ritaav", "fresaskoncremq", "yazminsitq", "exorcismxq", "jerezanotravis"]
WEBHOOK_URL = "https://discord.com/api/webhooks/1446757512081707071/SKZzU2b3RHs-yz3g6iTOonfIz9SR-ZTd04sjCPeJ4uQ5oTG5SqGMtXv-7s09XoCxwyap" # <--- Â¡PON TU WEBHOOK!

# Usamos Imginn
BASE_URL = "https://imginn.com/{}/"
HEADERS = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36",
    "Accept-Language": "en-US,en;q=0.9"
}

DB_FILE = "estado_privacidad.json"

def cargar_bd():
    if not os.path.exists(DB_FILE):
        return {}
    with open(DB_FILE, "r") as f:
        return json.load(f)

def guardar_bd(db):
    with open(DB_FILE, "w") as f:
        json.dump(db, f)

def enviar_discord(mensaje):
    if "TU_WEBHOOK" in WEBHOOK_URL: return
    
    data = {
        "username": "Monitor de Candados",
        "content": mensaje
    }
    try: requests.post(WEBHOOK_URL, json=data)
    except: pass

def chequear_estado(usuario):
    print(f"ðŸ•µï¸ Revisando: {usuario}...")
    try:
        r = requests.get(BASE_URL.format(usuario), headers=HEADERS, timeout=15)
        
        if r.status_code == 404:
            return "no_existe"
        
        soup = BeautifulSoup(r.text, 'html.parser')
        texto = soup.get_text().lower()

        # LÃ³gica de detecciÃ³n
        if "this account is private" in texto:
            return "privada"
        elif "downloads" in texto or "posts" in texto:
            return "publica"
        else:
            # A veces imginn falla en cargar, retornamos error para no dar falsos positivos
            return "error_lectura"
            
    except Exception as e:
        return f"error_red"

# --- EJECUCIÃ“N ---
print("--- Iniciando Rastreo (Reporte Total) ---")
base_datos = cargar_bd()
hora = datetime.now().strftime("%H:%M")

for usuario in LISTA_USUARIOS:
    # Pausa entre 4 y 8 segundos
    time.sleep(random.randint(4, 8))
    
    estado_actual = chequear_estado(usuario)
    msg = ""

    # 1. Manejo de Errores
    if "error" in estado_actual or "no_existe" in estado_actual:
        msg = f"âš ï¸ **{usuario}**: No se pudo verificar ({estado_actual})."
        enviar_discord(msg)
        continue

    # 2. Verificar Cambios
    if usuario not in base_datos:
        # Nuevo usuario
        base_datos[usuario] = estado_actual
        icono = "ðŸ”’" if estado_actual == "privada" else "ðŸ”“"
        msg = f"ðŸ†• **{usuario}** agregado a la vigilancia.\nEstado actual: {icono} {estado_actual.upper()}"
    
    else:
        estado_anterior = base_datos[usuario]
        
        if estado_actual != estado_anterior:
            # Â¡HUBO CAMBIO!
            if estado_actual == "publica":
                msg = f"ðŸš¨ðŸ”“ **Â¡ALERTA! {usuario} AHORA ES PÃšBLICA!**\nAntes: {estado_anterior} âž¡ Ahora: PÃšBLICA\n[Ver Perfil](https://instagram.com/{usuario})"
            else:
                msg = f"ðŸš¨ðŸ”’ **{usuario} puso el candado.**\nAntes: {estado_anterior} âž¡ Ahora: PRIVADA"
            
            # Guardamos el cambio
            base_datos[usuario] = estado_actual
            
        else:
            # SIN CAMBIOS (Lo que pediste)
            icono = "ðŸ”’" if estado_actual == "privada" else "ðŸ”“"
            msg = f"âœ… **{usuario}**: Sin novedades ({hora}).\nSigue estando: {icono} **{estado_actual.upper()}**"

    # Enviamos el mensaje a Discord
    enviar_discord(msg)

guardar_bd(base_datos)
print("--- Fin ---")